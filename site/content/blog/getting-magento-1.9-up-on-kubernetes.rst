=====================================
Getting Magento 1.9x up on Kubernetes
=====================================

I have been playing quite a bit recently on Kubernetes, and gotten various applications such as Sensu, Nginx, Hugo, Prometheus and a few others up and going on it. This is what amounts to one way to get Magento up on Kubernetes, on GKE. This guide is written for Magento developers looking to gain familiarity with Kubernetes, and perhaps Docker. If there are terms that you are unfamiliar with, or perhaps something I have worded badly, please let me know and I'll fix it up.

Things I intend to cover (or, todo)
-----------------------------------

- Metrics
- Logs
- Resource Allocations

The problem (or why should I care)
----------------------------------

Magento (the way I liketo run it) consists of a few moving parts:

#. PHP
#. NGINX
#. Redis
#. MySQL

Each of those parts have to run somewhere *reliably* in a known location. There might be several copies of these parts (most commonly the PHP/NGINX components) for redundancy, in case requests fail or get blocked. Further, in order to make any ongoing changes to the stack, we need to be able to quickly reason about exactly what's running, including versions, where the processes are running, how much resource they're using and when they were last modified.

A combination of Kubernetes and Docker serve to solve a lot of those problems elegantly. Docker images (run by the Docker daemon) are encapsulated, distributable environments to run a process in. They roughly consist of the following:

- A separate spot in the kernel to execute the process in.
- A root file system (including the application) to run things in.
- Reasonable isolation from other processes running on the same kernel.

Because they're encapsulated, the runtime environment is largely the same from development to staging to production, and beyond. This encapsulation solves one of the hardest problems: knowing exactly what's running.

Kubernetes provides a system to manage and distribute these Docker images among a series of machines, without caring about exactly where the image is running or setting up networking to that image. It manages the entire cluster, and is responsible for:

- Managing how much available compute resources there are in the entire cluster
- Deciding which machine a process should run on
- Starting and monitoring that process on the machine
- Creating a means to route to that process
- Provisioning any required cloud resources needed by that process instance
- Handling the failure of a machine

Kubernetes is entirely declarative, and is responsible for enforcing the state of your environment. It provides a superb abstraction between "the things the developer should know about" and "the gory detail the sysadmin needs to know about". We're going to use it because it dramatically reduces the impact of failure for any one component. If a process dies, it's restarted. If a machine dies, work is scheduled elsewhere. If Kubernetes dies, you're screwed -- but at that point, you were screwed anyway.

Getting Started
---------------

Our own, tidy workshop
""""""""""""""""""""""

Most of the resources in Kubernetes operate in the context of a namespace. A namespace prevents collisions between applications that need to be discovered, lets us sets some resource limits and (coming soon) network policy. To provision anything, we have to have a namespace to put it. `Check out the namespace docs for more information.`_

Kubernetes creates resources based on text configuration, in either JSON or Yaml. I like Yaml, so we're going to use that. So, let's get started, and create a namespace resource. Create a file called `20-m1onk8s-littleman-co.ns.yml` with the following content: 

.. Code:: yaml

  ---
  # Generated by Boilr at 19/6/15
  apiVersion: "v1"
  kind: "Namespace"
  metadata:
    name: "m1onk8s-littleman-co"
    # See http://blog.kubernetes.io/2016/04/Kubernetes-Network-Policy-APIs.html
    # net.alpha.kubernetes.io/network-isolation: "off"

You'll notice a few things about this file:

#. It's got a comment that indicates it's generated. I'm too lazy to generate them myself, so I use a templating tool called `boilr`_. If you like, the templates are available on `the littleman.co GitHub`_.
#. "`net.alpha.kubernetes.io/network-isolation`_: "off"" is commented out. Alpha resources are not available on GKE; when this feature is beta, I'll try and remember to update this.
#. The file is prefixed with the number 20. We're applying lots of configuration at once, and this number determines what order to apply the configuration in.

Simple Applications
"""""""""""""""""""

There are pre-build images for MySQL and Redis that can be deployed as is, and require very little effort on the part of the developer. We're going to start with those, as Kubernetes has quite the learning curve, and it's nice to start slow.

The way I like to get applications running on Kubernetes is to have:

- A `deployment`_ artifact: Something to indicate what to run on Kubernetes, and how many copies.
- A `service`_ artifact: Something to indicate how to route things on the network, and to where.

We'll start with the deployment. A deployment looks like this:

.. _boilr: https://github.com/boilr
.. _Check out the namespace docs for more information.: http://kubernetes.io/docs/user-guide/namespaces/
.. _deployment: http://kubernetes.io/docs/user-guide/deployments/
.. _service: http://kubernetes.io/docs/user-guide/services/
.. _net.alpha.kubernetes.io/network-isolation: http://blog.kubernetes.io/2016/04/Kubernetes-Network-Policy-APIs.html
.. _the littleman.co GitHub: https://github.com/littlemanco/
